-- KKBOX Churn Prediction Feature Engineering
-- Implements leak-safe temporal windows as specified in leak_audit.md
--
-- Key principles:
-- 1. For label month M, use data up to end of month M-1
-- 2. No joins to events after the cutoff for any sample
-- 3. Explicit as-of timestamps on all aggregations
--
-- See CITES.md for official sources and leak_audit.md for exclusion rules

WITH
-- Configuration: Define cutoff dates per sample
label_index AS (
  SELECT
    tr.msno,
    tr.is_churn,
    -- Use March 1, 2017 as cutoff for training samples
    DATE '2017-03-01' AS cutoff_ts,
    DATE '2017-03-01' - INTERVAL '1 day' AS feature_cutoff  -- Feb 28, 2017
  FROM read_csv_auto('${train_path}') tr
  WHERE tr.msno IS NOT NULL
),

-- Parse transaction dates with safety checks
tx_parsed AS (
  SELECT
    tx.msno,
    TRY_CAST(
      strptime(CAST(tx.transaction_date AS VARCHAR), '%Y%m%d') AS DATE
    ) AS transaction_date,
    TRY_CAST(
      strptime(CAST(tx.membership_expire_date AS VARCHAR), '%Y%m%d') AS DATE
    ) AS membership_expire_date,
    CAST(tx.payment_plan_days AS INTEGER) AS payment_plan_days,
    CAST(tx.plan_list_price AS INTEGER) AS plan_list_price,
    CAST(tx.actual_amount_paid AS INTEGER) AS actual_amount_paid,
    CAST(tx.is_auto_renew AS INTEGER) AS is_auto_renew,
    CAST(tx.is_cancel AS INTEGER) AS is_cancel,
    CAST(tx.payment_method_id AS INTEGER) AS payment_method_id
  FROM read_csv_auto('${transactions_path}') tx
  WHERE tx.msno IS NOT NULL
    AND tx.transaction_date IS NOT NULL
    AND tx.membership_expire_date IS NOT NULL
),

-- TRANSACTION FEATURES (90-day window)
-- Aggregates transaction history respecting temporal boundaries
tx_features AS (
  SELECT
    li.msno,
    -- Plan characteristics (latest values before cutoff)
    LAST(tp.payment_plan_days ORDER BY tp.transaction_date) AS plan_days_latest,
    LAST(tp.is_auto_renew ORDER BY tp.transaction_date) AS auto_renew_latest,
    LAST(tp.payment_method_id ORDER BY tp.transaction_date) AS payment_method_latest,

    -- Aggregated transaction behavior
    COUNT(*) AS tx_count_total,
    SUM(CASE WHEN tp.is_cancel = 1 THEN 1 ELSE 0 END) AS cancels_total,
    SUM(tp.actual_amount_paid) AS revenue_total,
    AVG(tp.actual_amount_paid) AS revenue_avg,

    -- Discount behavior
    AVG(CASE
      WHEN tp.plan_list_price > 0 THEN
        CAST(tp.actual_amount_paid AS FLOAT) / tp.plan_list_price
      ELSE 1.0
    END) AS discount_factor_avg,

    -- Tenure (days from first transaction to cutoff)
    DATE_DIFF('day', MIN(tp.transaction_date), li.feature_cutoff) AS tenure_days,

    -- Recent activity (last 30 days)
    COUNT(CASE WHEN tp.transaction_date > li.feature_cutoff - INTERVAL '30 days'
               THEN 1 END) AS tx_count_30d,

    -- Payment consistency
    COUNT(DISTINCT tp.payment_method_id) AS payment_methods_count

  FROM label_index li
  LEFT JOIN tx_parsed tp ON li.msno = tp.msno
  WHERE tp.transaction_date <= li.feature_cutoff  -- CRITICAL: No future data
    AND tp.transaction_date >= li.feature_cutoff - INTERVAL '90 days'  -- 90-day window
  GROUP BY li.msno, li.feature_cutoff
),

-- Parse user log dates with safety checks
logs_parsed AS (
  SELECT
    ul.msno,
    TRY_CAST(
      strptime(CAST(ul.date AS VARCHAR), '%Y%m%d') AS DATE
    ) AS log_date,
    CAST(ul.num_25 AS INTEGER) AS num_25,
    CAST(ul.num_50 AS INTEGER) AS num_50,
    CAST(ul.num_75 AS INTEGER) AS num_75,
    CAST(ul.num_985 AS INTEGER) AS num_985,
    CAST(ul.num_100 AS INTEGER) AS num_100,
    CAST(ul.num_unq AS INTEGER) AS num_unq,
    CAST(ul.total_secs AS INTEGER) AS total_secs
  FROM read_csv_auto('${user_logs_path}') ul
  WHERE ul.msno IS NOT NULL
    AND ul.date IS NOT NULL
),

-- USAGE FEATURES (30-day window)
-- User listening behavior patterns
usage_features AS (
  SELECT
    li.msno,

    -- Activity volume (30-day window)
    COUNT(*) AS logs_30d,
    SUM(lp.total_secs) AS secs_30d,
    SUM(lp.num_unq) AS unq_30d,
    SUM(lp.num_25) AS plays_25_30d,
    SUM(lp.num_100) AS plays_100_30d,

    -- Engagement quality
    AVG(CASE WHEN lp.num_25 > 0 THEN
          CAST(lp.num_100 AS FLOAT) / lp.num_25
        ELSE 0 END) AS completion_rate_avg,

    -- Listening consistency
    COUNT(DISTINCT lp.log_date) AS active_days_30d,
    AVG(lp.total_secs) AS secs_per_day_avg,

    -- Recent activity decay (last 7 days vs prior 23 days)
    AVG(CASE WHEN lp.log_date > li.feature_cutoff - INTERVAL '7 days'
             THEN lp.total_secs ELSE 0 END) AS secs_recent_7d,
    AVG(CASE WHEN lp.log_date <= li.feature_cutoff - INTERVAL '7 days'
             AND lp.log_date > li.feature_cutoff - INTERVAL '30 days'
             THEN lp.total_secs ELSE 0 END) AS secs_prior_23d

  FROM label_index li
  LEFT JOIN logs_parsed lp ON li.msno = lp.msno
  WHERE lp.log_date <= li.feature_cutoff  -- CRITICAL: No future data
    AND lp.log_date > li.feature_cutoff - INTERVAL '30 days'  -- 30-day window
  GROUP BY li.msno, li.feature_cutoff
),

-- Parse member data with safety checks
members_parsed AS (
  SELECT
    m.msno,
    CASE
      WHEN m.gender IN ('male', 'female') THEN m.gender
      ELSE 'unknown'
    END AS gender,
    CASE
      WHEN TRY_CAST(m.city AS INTEGER) BETWEEN 1 AND 25 THEN TRY_CAST(m.city AS INTEGER)
      ELSE NULL
    END AS city,
    CASE
      WHEN TRY_CAST(m.bd AS INTEGER) BETWEEN 10 AND 80 THEN TRY_CAST(m.bd AS INTEGER)
      ELSE 25  -- Default age
    END AS age,
    CAST(m.registered_via AS INTEGER) AS registered_via,
    TRY_CAST(
      strptime(CAST(m.registration_init_time AS VARCHAR), '%Y%m%d') AS DATE
    ) AS registration_date
  FROM read_csv_auto('${members_path}') m
  WHERE m.msno IS NOT NULL
),

-- DEMOGRAPHIC FEATURES
-- User profile and registration characteristics
demo_features AS (
  SELECT
    li.msno,
    mp.gender,
    mp.city,
    mp.age,
    mp.registered_via,

    -- Registration tenure
    DATE_DIFF('day', mp.registration_date, li.feature_cutoff) AS registration_tenure_days

  FROM label_index li
  LEFT JOIN members_parsed mp ON li.msno = mp.msno
)

-- FINAL FEATURE ASSEMBLY
-- Combine all feature groups with proper null handling
SELECT
  li.msno,
  li.is_churn,
  li.cutoff_ts,

  -- Transaction features (fill nulls for users with no transaction history)
  COALESCE(txf.plan_days_latest, 30) AS plan_days_latest,
  COALESCE(txf.auto_renew_latest, 0) AS auto_renew_latest,
  COALESCE(txf.payment_method_latest, 1) AS payment_method_latest,
  COALESCE(txf.tx_count_total, 0) AS tx_count_total,
  COALESCE(txf.cancels_total, 0) AS cancels_total,
  COALESCE(txf.revenue_total, 0) AS revenue_total,
  COALESCE(txf.revenue_avg, 0) AS revenue_avg,
  COALESCE(txf.discount_factor_avg, 1.0) AS discount_factor_avg,
  COALESCE(txf.tenure_days, 0) AS tenure_days,
  COALESCE(txf.tx_count_30d, 0) AS tx_count_30d,
  COALESCE(txf.payment_methods_count, 0) AS payment_methods_count,

  -- Usage features (fill nulls for users with no activity)
  COALESCE(uf.logs_30d, 0) AS logs_30d,
  COALESCE(uf.secs_30d, 0) AS secs_30d,
  COALESCE(uf.unq_30d, 0) AS unq_30d,
  COALESCE(uf.plays_25_30d, 0) AS plays_25_30d,
  COALESCE(uf.plays_100_30d, 0) AS plays_100_30d,
  COALESCE(uf.completion_rate_avg, 0.0) AS completion_rate_avg,
  COALESCE(uf.active_days_30d, 0) AS active_days_30d,
  COALESCE(uf.secs_per_day_avg, 0) AS secs_per_day_avg,
  COALESCE(uf.secs_recent_7d, 0) AS secs_recent_7d,
  COALESCE(uf.secs_prior_23d, 0) AS secs_prior_23d,

  -- Behavioral derived features
  CASE
    WHEN COALESCE(uf.secs_prior_23d, 0) > 0 THEN
      COALESCE(uf.secs_recent_7d, 0) / uf.secs_prior_23d
    ELSE 0
  END AS activity_decay_ratio,

  -- Demographic features
  COALESCE(df.gender, 'unknown') AS gender,
  df.city,
  COALESCE(df.age, 25) AS age,
  COALESCE(df.registered_via, 0) AS registered_via,
  COALESCE(df.registration_tenure_days, 365) AS registration_tenure_days

FROM label_index li
LEFT JOIN tx_features txf ON li.msno = txf.msno
LEFT JOIN usage_features uf ON li.msno = uf.msno
LEFT JOIN demo_features df ON li.msno = df.msno
ORDER BY li.msno;
